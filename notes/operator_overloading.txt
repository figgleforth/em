I think I know what has to be done to achieve the operator declarations that I'm imagining.

First, the lexer needs to be updated to allow groups of symbols as an identifier. I already left a todo there. To be thorough, I should manually write out what identifiers can start with, have, and end with. Having those rule will make it a lot easier for everyone.

Add a stage between lexing and parsing, it receives the tokens just like the parser does. It splits the tokens by the operator keyword token. That will give me an array of arrays, which contain tokens in between every single operator keyword. Operator keyword will be discarded by the split function. But that's OK, we're only interested in the next few tokens after the operator keyword.

The idea is that we're going to get the identifier symbol or group of symbols, then we're going to inspect the parameter declaration. it has to be a specific pattern for it to recognize prefix, postfix, infix. Parameter left implies postfix op, parameter right implies prefix, parameter "other" implies binary.

Once we've mapped all of the operator identifiers and the type of fix it is, this phase is completed.
Result is that we have a dictionary of identifiers where the keys are the type of operator fix it is.

now in the parser, The binary operator will be easy. In that while loop after the AST variable is assigned, We're gonna reference that dictionary of custom operators.

Ast = if ... end

If ast == prefix op: create Prefix_Expr(op, right: make_expression)

If next is postfix op, make pop last expression, make Postfix(op, left: popped expr)

If next is infix, Binop(left: ast, op, right: make_expression)

 I don't yet know how to handle precedents, maybe custom operators have automatic top precedence. Or maybe I'll come up with a way that lets you specify the precedence. like maybe by supplying it an existing operator, it will just use that precedence. Or maybe it just takes a number, and you reference the precedence table that I've already created. I don't know yet.

as for the prefix operator, I don't actually know how to handle that. It's probably similar to the unary operator, so I would start looking there.

As for the post fix, I'm also unsure.

However, all of this is enough for me to get started. I spent yesterday and today making no real progress because I didn't have a direction to go. This is the direction I need to go.

Also came to the realization that I don't need to invent symbols for things like puts and whatever. It should be a standard library that I can call like IO.print
IO.read
the cool thing though, is that you can make an alias for whatever symbol works for you. And put it in Global
Operator >! { right -> IO.print(self) }
And there's our prefix operator >! <expr>

Point being that there should be built in classes for probably most operator style that I'll imagine.

%%% 8/2/24

Usually operator overloads are class-level, like override :+ on Object or whatever. What an idea is, you could define how operators would behave on functions, and it would take precedence over the operator that would normally by used.

	secret = 0
	num { secret }
	num ++ { secret + 10 }       # with !! postfix
	-- num { secret - 10 }       # with !! prefix

	num++    10
	--num   -10

Suppose these ++ and -- operators are already defined on a number. Just imagine the implementation.

	Number {
		++ { left -> }
		-- { left -> }
	}

The ++ and -- defined on `num` take precedence over the ones defined on Number.

What about these as the right side of a binary expression?

	left.--right
	(left  .  prefix(--  right))

Order of evaluations:
1. left gets evaluated and put onto stack
	(with a dot operator for .member access, left needs to be pushed onto the stack so we can use #get)
2. evaluate right
	(Runtime will have some way to look up a prefixed function call from the current scope)

In this case, left should have the `-- right {}` defined so that #get is able to locate it after left is on the stack.

I also need to first wrap my mind around declaring pre/in/post operators.

	When it's a post fix operator, the receiver is the left side
	When it's a prefix operator, there's no receiver
	When it's an infix operator, there's no receiver

So postfix operators are declared on the receiver.
Prefix and infix operators are declared in a scope where those operators will be used.

How do we differentiate between them syntactically?

	it's a call to the operator with right as the argument
	Hatch {
		maintain { numbers -> }
		open { }
		* { left, right -> }
		# { right -> }

		`the word indicates what side the operator is on.
		`hatch#

	}

%%% Syntax ideas

The underscore is a hint at what the subject of the operator is.

	operator_ # { right -> }
	_operator # { left -> }
	_operator_ # { left, right -> }

Or entirely new words? I like them to line up nicely unlike the underscored operators above.

	Number {
		begop $ { -> "$self" }
		endop % { -> "self%" }
		midop : { right -> "self:right" }
	}

	$48     `$48
	15¢     `15¢
	16%     `16%
	23:42   `23:42

This might be the cleanest syntax, by far. Another example of letting the words themselves mean something to the language.

	Number {
		operator { $, right -> }
		operator { left, % -> }
		operator { left, :, right -> }

		operator { $ _ -> }
		operator { _ % -> }
		operator { _ :  -> }
	}

Or alternately, left and right are declared by the runtime and you don't have to specify which at all. Since the operator is recorded as an operator already anyway, what's an extra check for pre/in/post? I think

	Number {
		operator $ { -> }

		operator % { ->
			when left
			when right
			when both
		}

		operator : { ->
			if left and not right {
			elsif right and not left {
			elsif both
			}
		}
	}

Two justifications for allowing = to be overloaded

1) =; is reserved for declarations. Builtin = behaves as expected. Programmer is responsible for using it safely
2) Cool example

	Element {
		number =
		symbol =

		operator = { right
			`you can modify the assignment in realtime
			`the expression returned is what the final assignment is
			`it can be anything, even nil

			if right == 36 or right == 'Kr' {
				return Krypton.new
			}

			nil `the last expr is the implied return
		}
	}

	element = Element.new # the equals sign is not yet overloaded
	element = 123 # nil
	element = 36  # Krypton
