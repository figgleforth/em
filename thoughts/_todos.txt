Now that parsing is working again, and is more robust, I can finally implement the proper enum syntax without the equals sign.
ENUM {} versus ENUM = {}

Set up the pipeline rake task. It should

For better performance, maybe go through and get rid of the .tap blocks from many of the trivial Token/Expr initializations. I'm actually not sure how that works under the hood. I imagine the block is pushed onto the stack.

Logical keywords "and" and "or" should behave like && and ||, unlike in Ruby where they have slightly different behavior. On that note, check all usages of and/or/not because I'm no longer confident that I used them correctly throughout the project. However, everything does work correctly so it is probably fine. I do prefer the usage of the word in most cases as it is easier for me to type quickly.

Color-code repl output based on type of value (string, number, Ref, call, etc). I think that would be a wise use of visuals for information at a glance.

If I can make function calls work without parentheses, I still want to be able to pass class decls and func decl/exprs around, maybe with % or $ prefix
funk {}

Right now it's difficult to tell what operators the language reserves, and which sets of symbols make pre/post/infix operators. It would be nice to have a more robust lookup rather than just some constants in Token

You should be able to chain while loops with conditionals
if condition {
	runs once
elswhile condition
	loops
else
	runs once
}
while condition {
	loops
elsif condition
	once
}
So all *ifs run once, all *whiles loop. I imagine this could be useful

Backticked comments, they start and end with backticks. This would be cool, you could insert a comment in the middle of a binary expression, as an example:
result = 123 / `this divisor cannot be zero` divisor
This comment here would be completely ignored.
This would also eliminate the need for a special multiline comment symbol. The parser would keep parsing until the comment is closed out

A new keyword for breaking out of all loops, to the closest block. Those would be anon and conditional loops

Do I even need the EOF token? It seems pointless since I'm going to parse until I run out of tokens anyway.

Make the pipeline more consistent
Lexer.new(input).output
Parser.new(input).output
Runtime.new(input).output

Clean up the eat Identifier_Token.string shit. I can't make proper error reporting without access to the token and its source code position information.

Look at what makes identifiers again. Let's really solidify what they can start with, contain, and end with. I want this to be solid and coherent, especially because the current direction is heading towards symbols as identifiers. So I need to have consistent rules on what can and cannot be used as an identifier.

Bug in raise, probably with syntax
raise expression unless condition   # works as expected
raise unless condition              # raises even when it should not

Bug assigning blocks
% = { -> 12 }
◼︎ 12
%
◼︎ 12
Only in this case, when assigned, the block is instantly evaluated. It doesn't affect passing func declarations around though

I'm removing Macro_Token, and Macro_Expr and Macro_Command bullshit. Instead parser should have only one Token type for a complex symbol. That's what these symbols would do:
%S()
   it.identifiers.map!(&:upcase)
%s()
   it.identifiers.map!(&:downcase)
%V()
   ['BOO', 'HOO']
%v()
   ['boo', 'hoo']
%W()
   ["BOO", "HOO"]
%w()
   ["boo", "hoo"]
%d()
   {boo: nil, hoo: nil}
%D()
   {BOO: nil, HOO: nil}
%()
   %(1, 2, 3) tuples

REPL ls output is incorrect
House { Mac {} }
◼︎ {"types"=>["House"], "Mac"=>{"types"=>["Mac"]}}
Mac
◼︎ Undeclared 'Mac' in Global { String, Array, Hash, House }
cd House
◼︎ Peek { types, String, Array, Hash, House }
Mac
◼︎ {"types"=>["Mac"]}
ls
◼︎ Peek { types, String, Array, Hash, House }
Why is Mac available but not visible with ls?

Idea – some kind of class that receives all the output, kind of like REPL does. And catches for custom exceptions. Like Log, Warning_Log, etc. So when runtime sees >!! it could raise Warning_Log. Then REPL and this output receiver could rescue against Warning_Log and handle it as they need to

I added the raise keyboard to raise and exit the program. Not totally sold on it, but it's fine for now. It currently only raises the message, but I want it to behave like an assert
raise message unless condition
raise message
This will be an example on inline conditionals but just when parsing this keyword.
Anyway, something about this syntax bothers me. Is there a set of symbols that can be used? Can the language be changed? The order of message vs condition?


I think I figured out the block composition problem. I used to think that I need to push the composed object onto the stack, then a thin block scope on top. But this is way too complicated. Instead, any parameter that is designated as a composition, if it responds to a member that you are using in the block,Then push the object, evaluate, then pop the object. It doesn't need to be permanently in the stack, only when you need it.
As for class composition, that has to remain as is. Composed classes, definitely need to have their guts modified based on the composition. Whereas a block is only temporary.
This system removes the need for layers of the stack that are in array. I can't imagine any other scenario where I would want that.
Additionally, I think block composition should be valid both in the parameter declaration, and in the body. When it is used in the body, the composition doesn't happen until it is evaluated.
It would be great to also have the ability to remove the composition, For that, I want to use ~ident. This one can only be used in the body.
So the main differentiator between class and block compositions are the symbols and their abilities. While they are both compositions, class is permanent while block is temporary.
GET RID OF SCOPE as ARRAY of SCOPES

Also, I think the Scope structure should change to reflect compositions
	Class {
		> One
		+ Two
		+ Three
	}
should look like
	Static {
		@ = {
			compositions = {
				> = [One]
				+ = [Two, Three]
			}
		# methods from One, Two, and Three, and other declarations
	}
And the scope structure for blocks
	Transient/Temporary {
		@ = {
			compositions = {
				% = []
				# I want it to use the same structure as Static even though I don't envision more than the % composition operator. But in case I do, this is the prefect structure.
			}
		}
		# composition has no effect on the declarations of this scope
	}
The pattern is that

See notes/init_edge_cases for issue with instance creation. This has to do with how Statics and Instances are stored, and how an instance is created, using what data. I think Instances should not share the same members as Statics, it should make a copy of each member instead, where every member of the Static is initialized again.

Classes with all capitalized names are being parsed as constants. I think the answer here is that constants need to be assigned like dictionaries. Sorry, but I kinda wanna reserve expr {} for blocks and classes. Constants are assignments anyway, have them use =. Once this is fixed, update examples/declarations.em

When I design stacktrace output, please make it useful. Why does Ruby print it out in reverse? There's probably a reason but the stack trace is always so long that I end up having to scroll up to find the error. I want it to be reverse
Stack trace:
	oldest calls
	...
	newest calls
	...
	current error
	END OF PROGRAM OUTPUT

BUG) Composition is still bugged.
Maybe the issue is the stack sometimes having an array instead of a scope. Maybe for composition I need to think of a different way to do composition
This time:
	f { %what -> what }
	◼︎ %{f228a}
	f(Array.new)
	◼︎ undefined method `key?' for nil:NilClass
		`block in set': undefined method `key?' for nil:NilClass (NoMethodError)
		if scope.key? identifier
              ^^^^^
		from /Users/bp/Code/ruby/em/source/interpreter/runtime.rb:217:in `reverse_each'
		from /Users/bp/Code/ruby/em/source/interpreter/runtime.rb:217:in `set'
		from /Users/bp/Code/ruby/em/source/interpreter/runtime.rb:640:in `block in block_call'
		from /Users/bp/Code/ruby/em/source/interpreter/runtime.rb:620:in `each'
		from /Users/bp/Code/ruby/em/source/interpreter/runtime.rb:620:in `with_index'
		from /Users/bp/Code/ruby/em/source/interpreter/runtime.rb:620:in `block_call'
Last time:
	f { %what -> what }
	◼︎ %{512.c8c}
	ls
	◼︎ Global{String,Array,Dictionary,f}
	f(Array.new)
	◼︎ {"types"=>["Array"]}
	ls
	◼︎ Global{String,Array,Dictionary,f,what}
See how the `what` identifier from the function was declared in the global scope? It should only have been declared in the Block scope

Todo, rethink literal macro shortcut. I need to use % for composition. See lexer.rb:21

REPL issue – cd'ing into a scope, then ls'ing shows Hash{ ... }. I want it to show whatever you cd into.
cd String
ls
String{ ... }

Some languages use the words standard and core for the builtin library. I want it to be universe.
universe/
	- string.em
	- number.em
	- array.em
	- dictionary.em or hash.em
	- etc
The idea is that each of these classes will be added to the global scope at runtime. Then in #eval, when we encounter a String_Literal_Expr, we can replace returning #to_s with our own internal String class. So now my name = 'boo' variable is holding an instance of String {}.
Same goes for the other Exprs, Dictionary_Literal -> Dict/Hash. Array_Literal -> Array. "" -> String, etc
They should also correspond to metaprogram classes with the same, or similar, name.
source/universe
	- string.rb
	- etc
Since these are going to be hashes anyway at runtime, why not make these universe classes extend Hash. That way on program start we can do #set 'String', source/universe/string.rb which is a Universe hash. Or whatever the terminology is. These hashes are going to be Static declared in the global scope, but a "" will evaluate to the Instance version of String.


All major keywords should be defined in Global. cd is one of them. It can be empty, maybe a new like Builtin_Ref or something. It needs to be present so that when we list out members in any scope, even the builtin ones are present.

Global alias ../ allows you to reference anything in global explicitly
../String
../Number
etc

Current instance alias ./ which is the equivalent of `self` in ruby.
Island {
	../ # refers to the scope outside Island
	./ # refers to the Island
	open { ->
		../ # global
		./ # Island
	}
}

Breakpoint snake >~. It should pause execution, push a temporary Block scope, start REPL and allow entering any expressions. And it can even interact with the current program. Just figure out how, if the program is paused.
Anyway, I want to implement the export command. `>~ export` or `>~` then `export` once at the breakpoint. The oneliner should do the export then put you in the REPL right there
It should export the entire Global scope to a json file, which should be possible since the entire program is just a hash of Ruby objects, most of which, if not all, are serializable. So this should be easy.
After that, I want to load up the program and continue evaluating it from where the export happened. It should enter the REPL in that place and let you continue. This would make debugging so easy – >~ export right before your bug. Then start the program with the exported file to immediately start at the >~ without having to wait for things to execute to get to that point.

Improve test system such that each test run of a file stores the final runtime/interpreted value of the program. and it has to == true. Run each test one by one and record failures of all the ones that don't evaluate to true. This way it can do all tests

Add slimmer form of if-else statements. I don't want to type curlies all the time. I would prefer:
if condition: do_some_expr
if condition do_some_expr # this should be possible because after :if we make_expression so it should only get 1 expression. At which point we can parse the next thing. If it isn't a { or :, then it has to be an inline expression. In this case we don't even need to parse for } cause we know it won't have one
Same for while
while condition expr
while condition: expr
Eventually implement that inline else syntax. if condition expr else expr

Thought – consider the mutability of an inline composed object, like funk { %comp -> }. Its guts are local to the block so can be edited. But comp is what, a copy?

Inline composition has a new symbol. %. It looks like two circles touching, separated by a diagonal line. Two sets touching. Two scopes touching.
func { %input, other ->
	# access input's declarations here without prefixing with input
	%other # works in the body as well, and won't be composed until the line is evaluated
	%Math # works with classes as well
	%some_other_func # I guess with other scopes as well, why not?
	# all inline compositions, or whatever the feature name becomes, are reverted at the end of the current scope. Unlike class compositions, which are permanent for the class.
}

Idea for References
Currently only Block_Exprs are converted into references. The ID of the reference is just SecureRandom.uuid/hex/whatever. Instead I want it to do something like:
	expr.expressions.map(&:to_some_constant_string_form).join().hash
As long as the expressions can map to some constant string form, then the hash should be able to catch blocks which are identical. And that's regardless of spacing! Because it goes based on the expressions.

Idea for Scopes
@ key is the guts that contain all declarations that would come standard on the object.
	Identifiers inside guts should be accessible via guts shorthand. @ident. @id for @.id, @types for @.types, etc. And it should just work because the Runtime implements dot access on Hashes, and all scopes are hashes so it just works
_ key contains all private declarations. identifier lookup includes _ depending on where you are evaluating from. Inside a class means you can call the class's private. Inside a class's function or a temp block inside a function means you can also look into _. There's probably a scenario where you can't.
It would be good to make a concrete chart or something, denoting which scopes can access _.

Class composition shortcut should be user choice.
Class > Other {} means Class inherits Other type as well as declarations
Class + Other {} means class inherits only declarations
The compositions are comma separated so you can add many
Class > Other, Other2, Other3 {}
Class + Other, Other2, Other3 {}
BUT, you can only use < or + in this inline version, not both. You can use both inside the class
Class {
	> Other
	+ Other2
}

Exercise: list out all Exprs. Hand draw what the scope tree would look like for evaluating each type of Expr. Really understand each one of the evaluations before we code it.

Is Global part of the stack [Global, Scope, Scope, etc] or is Global a separate scope outside of the stack?

Parse for `()` and make that the operator to "call" the previous expression.
ident, () means to call that ident
number, () should give syntax error
This would be the new version of Block_Call_Expr. Where if the parser parses a () operator, it should create a new Call_Expr(expr = previous parsed expr). This is a more generic Block_Call_Expr. Think about how ( with params ) differs. Maybe it's also a Call_Expr. As far as Runtime is concerned, it doesn't care. All it needs to know if if Call_Expr, what is the identifier, what are the arguments to pass in. So
Call_Expr(receiver, identifier, arguments)

I want to be able to give a block to any expression, and have that block's `it` be the expression.
I'm thinking like
funk { -> }
funk() {
	it # is the result of the call
}
Woof{}.new {
	it # is the instance of Woof
}

It would be cool to be able to pause execution, serialize the global Static_Scope into some output file. Then you could resume the program fresh from the command line by supplying it the output file

I think I need to differentiate between var assignment and var declaration. It would help, especially when assigning variables from within nested blocks. Currently if there's an `x = 1` in the global scope, and in a block `x = 2`, the global scope x stays unchanged.
A related BUG: in #eval_block for anonymous blocks, if I push a scope then it breaks while loops. I think while loop's anon block evals on the current scope, so by pushing a scope, the x = 2 is declared on that scope and not over

Implement class functions. #new is reserved for inits. Also make #new() work, check #eval_block_call
d = Dog.new
◼︎ #<Instance_Construct:0x00000001006174d8>
d = Dog.new()
◼︎ Calling class functions or variables is not implemented

Cleanup Expr, after removing @short_form I replaced each instance of that to `false`.

Functional and while blocks builtin variables it, at, skip, stop. Later I'd like to add a delete keyword for arrays so you could do something like
[1, 2, 3].each { ->
	if it == 2 { remove }
}
# => [1, 3]
An alternate version, which I like. I actually like them both, I'm sure there's a use case for the remove keyword
[1, 2, 3].remove { ->
	it == 2
}

Upgrade the entire language pipeline. Currently each time I need to parse/interpret, I have to create a local instance of Lexer, then Parser, then Interpreter. Maybe there should be some class that handles the entire pipeline, and you could specify what stages you want (lex, parse, interpret). Obviously parse requires lex and interpret requires lex and parse. But this should definitely be an option.
This would also allow other options, like documenting and server stuff.
Don't just replace all places where these are locally created, do that methodically. For example, parser sometimes calls a new instance of itself, so that doesn't need an entire pipeline.

Use signature for declaration setting and lookups

Investigate parser creating a new instance of itself and having it parse output. I can't remember why I did that, maybe because Parser has @expressions and the #parse loop adds to expressions each time it runs once. So you could end up in a situation where you are mid parsing something where you have to call #parse in a nested manner, the inner #parse call will append to @expressions before the outer #parse call does, which would lead to incorrect parsing. So maybe this isn't a problem at all?

Improve error messaging. It is currently a pain in the ass to figure out error messages. It doesn't even return a location for the offending code – that would be a good place to start.

Block_Expr.compositions are just strings, I think they should be Identifier_Exprs
Parser: when eating tokens into expressions that have a :name attribute, always store the token and not just token.string. That's currently how it is, but I need the actual, especially because Token has or should have cursor position info
Generalization: Think about whether I really need Tokens stored on Asts

REPL needs to call inspect or whatever on the output so that the interpreter isn't making those transformations. That would solve my issue of trying to `>! some_instance` where it prints <Instance:#13241234> or whatever the object prints like in Ruby.
I tried having #evaluate return an inspect-like string for Instance_Construct, but that breaks interpretation because #evaluate should really be dealing with constructs to product a value, not string representations of a construct

Figure out string interpolation. See String_Literal_Expr#string=
This might be tricky. I can pull out all expressions
	"Testing `a + b * c` or `boo`".scan(/`([^`]+)`/).flatten # => ["a + b * c", "boo"]
So I think the interpreter needs to put each of these into a new lex+parse instance. then when it gets those results back, it can call #evaluate with each one to get the value.
The interpreter should also make a dictionary out of the extracted expressions. Then when each one is evaluated, store the output as its value. Later when they're being replaced into the string, it will be easy to replace even the complex expressions by string. Example of replacing:
	replacements = {
	  'name' => 'Locke',
	  'day' => 'tomorrow'
	}
	"`name`, today is `day`".gsub(/`([^`]+)`/) { replacements[$1] } # => "Locke, today is tomorrow"

Cannot escape strings. Probably should be lumped with string interpolation work.
'Test\'ing'
◼︎ Expected ''' but got ''
"Test\"ing"
◼︎ Expected '"' but got ''
\n also doesn't work.
> "Apparently not\n"does interpolation work yet? `result`""

Concatenating strings still broken for two strings.
>! 'Test ' + 'this'
"Test "this""

Operator overloading. Add new Operator_Token keyword, I need operators to be identifiable by pattern so that I can check for [Keyword_Token(operator), Operator_Token([] or other binary operator)]. Store it as a named Block_Expr aka function. The name is the operator. For Subscript should be named `[]`. So when interpreter encounters a Subscript_Expr, treat that as a Binary_Expr where left is subscript.left and the operator is dot, and the right is get_from_scope :functions, '[]'.
Any operator should be able to be overloaded, even ranges. Even `.`? That might be wild. So you can't change it on a global scope but you can on a class
Abc {
	operator . { other ->
		if other == 'new'
			>! 'called .new on `self`'
		}
	}
}
Thoughts today (without reading above thoughts): override operator with `operator` keyword. All operators have built in implementations by default but can be overloaded with `operator == { other -> }`, which gets executed on the receiver. To achieve that:
1) update parser to create named Block_Expr where name is the operator token
2) interpreter should store this under functions['=='] = Block_Construct or whatever
3) interpreter should call these functions when encountering them while parsing Binary_Exprs, since that's really the only place these operators will ever be present.

Apparently you can add members to an instance at any time by doing instance.whatever {} or instance.whatever = 'boo'. I kinda like that but it feels wrong, actually. Consider whether to keep this behavior. I just thought of a useful case for this – interpreter could have debug and release modes. In debug mode, you can add instances like this to make building the thing easier. In release mode, it would fail to interpret. I like this a lot.

Issue interpreting. I wonder what to do about this. I plan to support .0, .1, etc as a binary expression to be able to easily access arrays by index (arr.1, arr.2, etc). That would be so nice. Once operator overloading works, you could overload . on Array and have it call through to []. Something like `operator . { right -> self.[right] }`.
Abc { boo = 'boo' }.new.boo
◼︎ "boo"
Abc { boo = 'boo' }.new.boo.1
◼︎ 0.1

Implement '@' context operator, for accessing functions and variables internal to an instances, for example, @some_member. eg) all classes might have `id =;`, to access it use `@id`. That way the internal members don't pollute the instance(aka the current runtime_scope). The end result is that you can use any name for members, even internal ones. And the internal ones can be accessed only by prepending the member with @

Generalize Interpreter#evaluate when Block_Call_Expr so that Block_Expr evaluation uses the same code to call the block inline

Generalize parsing expressions between parens. I think the function call ast parses parameters between parens, so go look there. When abstracted it can be reused for tuples. Also where Parser#make_ast checks curr? '(' I'm calling make_expression again. But I think this is where I want to use #make_comma_separated_ast
#tuples

Add support for inline conditional at end of lines because they reads nicely: `move() if xy else stop()`
Possible strategy: pop last ast and replace with new ast to make conditionals (unless while if) work at the end of an expression. Pop last expression, it becomes the when_true of a Conditional_Expr

Why are there two arrays storing ascii symbols? Ascii_Token::BINARY_OPERATORS and Ascii_Token::UNARY_OPERATORS, and in Lexer::SYMBOLS. When you change one, you have to update the operator precedence in parser, and also lexer DOUBLE_SYMBOLS

Implement, a ? b : c or is that unnecessary? I kind of like the `expr if expr else expr` syntax.

abc ?? xyz (abc if abc, otherwise xyz). This is basically how Ruby's || works. Maybe I don't need this since the interpreter uses Ruby's || when interpreting Em's ||

Should nil be an object or just a string?

Use function signature in #get_construct and #set_construct? But I'm not sure how, since Function_Call_Expr only knows a function's name.

Double check why Identifier_Expr and Identifier_Token both have identical #constant?, #object?, and #member?

Clarity issue. Identifier_Expr/Identifier_Token #member? because it's not clear. Add #variable? and #function? and make #member? return `variable? or function?`

Consider identifiers starting with a number again like 1st, 2nd, 3rd?, 4th!, etc

Parser returns Nil_Expr when it parses `nil`. Should it work differently? I'm not sure yet

In both Lexer and Parser, create some kind of error message object that functions similarly to localization. Would be cool to allow you to customize the error messages. ERRORS(:some_error) could read errors from a custom file based on the current language, like errors/en.yml or something like that. So you could define your own error messages for the language. Pointless but probably fun

Repl: make ctrl+c cancel the current input. Currently it cancels the current line on screen but preserves the input prior to cancelling. So when you start typing the next line, even though it doesn't show the previous line, the previous characters are still part of some internal state that tracks typed characters.

Consider composition with members. Parser#make_ast prevents it

Figure out how to call functions without parens like in Ruby. See Parser#make_function_call_ast
When calling func without parens, think about how to handle collisions between variable and func names. Currently the interpreter lets you call a func without parens only if it takes no arguments. If it does, it prints a message stating the block expects args.

I like how Ruby has classes for builtin types, like TrueClass, FalseClass, Integer, etc. Reading through true_class.rb, it dawned on me that there's probably some preload.rb-like file that would declare `true = TrueClass.new` or something like that. For example, I'm currently lexing a Boolean_Token when an identifier is 'true' or 'false', then parsing that into a Boolean_Literal_Expr, and finally interpreting Boolean_Literal_Expr using Boolean_Literal_Expr#to_bool.
But maybe that would be ugly? Once I add types, do I really want to type `Int` instead of `int`? I feel like the capitalization will get annoying, plus it's ugly. So maybe foundational types like int, float, array, dict, etc should all be lowercase? Idk yet

Clean up Lexer#LEX – there's a mix of methods and some inline creations right at the conditional. It would be nice to be consistent.

Think about how to "interpret" the entire program before actually interpreting, even across multiple files, such that code doesn't have to be in a specific order, so that I can reference an identifier before it is declared.

multiline strings with ```
x = ```
a multiline string!
```

Annotation comments that start with special words or characters. They should be used somehow, like when parsed, add them to some generated file or something along those lines, then they are ignored and the parser moves on.
x =; # note: blah blah
Then in `docs/notes/whatever_file_it_came_from.txt|md`, or maybe just `docs/notes.txt|md` with aggregated notes. It should work for todo, bug, and anything else I can think of later
Maybe docs should mimic the structure of the application like, docs/app/models, docs/app/controllers, etc, or whatever structure it ends up being
Along these lines, documentation comments should have their own pattern at the beginning of the string so that they can be identified as documentation. Maybe documentation should be multiline (but this looks ugly):
###
Something, something, something
###
something { -> }

bug: Assignment_Expr when passed as argument is evaluated in the scope of the function. So in this case, wtf becomes available inside the go function
go { x-> wtf }
◼︎ #<Block_Construct:0x000000010228e4b8>
go(wtf =;)
◼︎ nil
wtf
◼︎ undefined variable or function `wtf` in scope: Global
go()
◼︎ undefined variable or function `wtf` in scope: go

Add autocomplete to REPL. See https://ruby-doc.org/stdlib-2.5.1/libdoc/readline/rdoc/Readline.html#method-c-completion_proc-3D-label-Examples

Loading other files, like Ruby's require and require_relative.
@load tests/sandbox.em
How to load into a specific scope, aka named?
@load tests/sandbox.em as sandbox
The idea is that this would load the contents of the file into the current scope. It could pollute the scope, so this would allow you to put it in its own scope, like a variable assignment
Jai allows passing arguments to the loaded file, like @import 'library'(some_flag = false), then this library can evaluate based on this flag. Think about how to allow files to specify params

Parser issue — cannot set blocks as values on a dictionary. `{ x = {->} }` fails saying parser doesn't know how to parse `}`. I think this has something to do with the way that #parse_until parses until the specified token

Make print >!!! functions take comma separated expressions because it feels nicer to type a comma than a plus, because the plus requires holding shift

Come up with something better than >! >!! >!!!, mostly because that's an ugly operator

Previous scope operator `../` like `../puck.bounce` to get `puck` from the previous scope

Idea – comma separated expressions should parse as an array
x = 1, 2, 3 #> [1,2,3]
funk { -> 1, 2, 3 }
funk() #> [1,2,3]

 Symbol for tuples? It would be cool for them to have their own unique symbols but {} and () and [] are all taken.
<1,2>
|1, 2|
%(1, 2)
