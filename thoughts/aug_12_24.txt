=== I should summarize what has changed, before I forget.

Lexer changes – important tokens have been reclassified:
- Identifier_Token (alphanumeric)
- Operator_Token (symbols)
- Key_Identifier_Token      Token::RESERVED_IDENTIFIERS eg. if, return, self
- Key_Operator_Token        Token::RESERVED_OPERATORS   eg. >!!! -> ..

And the usual
- Delimiter_Token
- Number_Token
- String_Token
- Comment_Token

Parser changes – #make_expr is now a two phase function:
	Phase 1 #make_expr:         Parse expression
	Phase 2 #augment_or_dont:   Transform expression

The transformation phase makes it easy to handle pre, post, and infix operations:

	eg. Prefix
		Phase 1 — expr = Operator(!)
		Phase 2 — Prefix_Expr(operator: expr, expression: make_expr)

	eg. Postfix
		Phase 1 — expr = Identifier(x)
		Phase 2 — Postfix_Expr(operator: eat, expression: expr)

	eg. Infix
		Phase 1 — expr = Number(1)
		Phase 2 — Infix_Expr(operator: eat, left: expr, right: make_expr)

	eg. Conditionals at the end of an expression, like `x unless y`

	Precedence is: prefix, postfix, infix

I have no clue what I'm doing, but it seems like this is gonna work out. Here are some extreme examples that I think parse the way I would want them to. Note that ! and !! are declared as prefix and postfix operators in Token, but !!! is not, so the parsing is correct in all of these cases:

	!a.b!
	Prefix(Op(!) Binary(member(a) . Postfix(member(b) !)))

	!!a.b!!
	Prefix(Op(!!) Binary(member(a) . Postfix(member(b) !!)))

	!!!a.b!!!
	Op(!!!)
	Binary(member(a) . member(b))
	Op(!!!)

	!!a.b!!c
	Prefix(Op(!!) Binary(member(a) . Postfix(member(b) !!)))
	member(c)


I think this'll be fine as long as the behavior of operators is consistent throughout the entire language.

=== Circumfix expressions

I'm considering adding circumfix operators, partly because it feels incomplete to not implement this, and also partly because it is cool. Circumfix means an expressions surrounded by operators, such as a parenthesized expression.

Currently that's a Tuple_Expr but because I've been able to generalize the rest of the parsing, I think it would be relatively trivial to generalize grouped expressions, too.

But circumfix wouldn't mean that I'd have to replace the current handling of grouped expressions. Maybe this should be for custom operators.

Above example as a circumfix operator

	!!a.b!!
	Circumfix(operator: !!, expression: a.b)

=== =; operator

Something to consider, =; might be pointless now that you can declare nil variables just by identifier. I haven't implemented the runtime part of that but this parses properly:

	Class {
		member1
		member2
	}
	Class{[member(member1), member(member2)]}
